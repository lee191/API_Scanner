"""Security vulnerability scanner for API endpoints."""

import requests
import re
from typing import List, Dict, Optional
from urllib.parse import urlparse, parse_qs, quote
from src.utils.models import APIEndpoint, Vulnerability, VulnerabilityLevel, HTTPMethod


class VulnerabilityScanner:
    """Scan API endpoints for security vulnerabilities."""

    def __init__(self, timeout: int = 10):
        """Initialize vulnerability scanner."""
        self.timeout = timeout
        self.vulnerabilities: List[Vulnerability] = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Shadow-API-Scanner/1.0 (Security Testing)'
        })

    @staticmethod
    def is_shadow_api(endpoint: APIEndpoint) -> bool:
        """
        ?�드?�인?��? Shadow API(?�겨�?문서?�되지 ?��? API)?��? ?�별.

        Shadow API ?�별 기�?:
        - /internal/, /admin/, /debug/, /test/ ???��? 경로 ?�함
        - /backup/, /config/, /secret/ ??민감??경로
        - /v0/, /beta/, /dev/ ??개발/베�? 버전
        - 비표준 HTTP 메소??
        - 문서?�되지 ?��? ?�겨�??�라미터
        """
        url_lower = endpoint.url.lower()

        # Shadow API ?�턴
        shadow_patterns = [
            r'/internal/',
            r'/admin/',
            r'/debug/',
            r'/test/',
            r'/backup/',
            r'/config/',
            r'/secret/',
            r'/hidden/',
            r'/private/',
            r'/dev/',
            r'/beta/',
            r'/v0/',
            r'/staging/',
            r'/temp/',
            r'/tmp/',
            r'/exec',
            r'/eval',
            r'/cmd',
            r'/_',  # ?�더?�코?�로 ?�작?�는 경로
        ]

        for pattern in shadow_patterns:
            if re.search(pattern, url_lower):
                return True

        # 문서?�되지 ?��? ?�라미터 (common names for hidden params)
        if endpoint.parameters:
            hidden_params = ['debug', 'test', 'internal', 'admin', 'dev', 'trace', 'verbose']
            for param in endpoint.parameters.keys():
                if param.lower() in hidden_params:
                    return True

        return False

    def scan_endpoint(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Scan a single endpoint for vulnerabilities."""
        vulns = []

        # Authentication check
        vulns.extend(self._check_authentication(endpoint))

        # CORS check
        vulns.extend(self._check_cors(endpoint))

        # Sensitive data exposure
        vulns.extend(self._check_sensitive_data(endpoint))

        # Rate limiting
        vulns.extend(self._check_rate_limiting(endpoint))

        # SQL Injection (basic check)
        vulns.extend(self._check_sql_injection(endpoint))

        # XSS (basic check)
        vulns.extend(self._check_xss(endpoint))

        self.vulnerabilities.extend(vulns)
        return vulns

    def scan_endpoints(self, endpoints: List[APIEndpoint]) -> List[Vulnerability]:
        """Scan multiple endpoints."""
        all_vulns = []
        for endpoint in endpoints:
            try:
                vulns = self.scan_endpoint(endpoint)
                all_vulns.extend(vulns)
            except Exception as e:
                print(f"[!] Error scanning {endpoint.url}: {e}")

        return all_vulns

    def _check_authentication(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for missing or weak authentication."""
        vulns = []

        try:
            # Try accessing without authentication
            response = self.session.request(
                endpoint.method,
                endpoint.url,
                timeout=self.timeout,
                verify=False,
                allow_redirects=False
            )

            # If successful without auth, it's a vulnerability
            if response.status_code == 200:
                vulns.append(Vulnerability(
                    type="Missing Authentication",
                    level=VulnerabilityLevel.HIGH,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="인증 없이 API 엔드포인트에 접근 가능합니다",
                    evidence=f"인증 정보 없이 HTTP {response.status_code} 응답을 받았습니다",
                    recommendation="인증 메커니즘을 구현하세요 (OAuth2, JWT, API Key 등)",
                    cwe_id="CWE-306"
                ))

            # Check for basic auth over HTTP
            if endpoint.url.startswith('http://'):
                if 'authorization' in [h.lower() for h in endpoint.headers.keys()]:
                    vulns.append(Vulnerability(
                        type="Insecure Authentication",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description="암호화되지 않은 HTTP를 통해 인증 자격 증명이 전송됩니다",
                        evidence="HTTP 프로토콜에서 Authorization 헤더가 발견되었습니다",
                        recommendation="모든 인증 엔드포인트에 HTTPS를 사용하세요",
                        cwe_id="CWE-319"
                    ))

        except requests.exceptions.RequestException:
            # Connection errors are not vulnerabilities
            pass

        return vulns

    def _check_cors(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for CORS misconfigurations."""
        vulns = []

        try:
            # Send request with Origin header
            headers = {'Origin': 'https://evil.com'}
            response = self.session.request(
                endpoint.method,
                endpoint.url,
                headers=headers,
                timeout=self.timeout,
                verify=False
            )

            # Check CORS headers
            acao = response.headers.get('Access-Control-Allow-Origin', '')
            acac = response.headers.get('Access-Control-Allow-Credentials', '')

            # Wildcard with credentials
            if acao == '*' and acac.lower() == 'true':
                vulns.append(Vulnerability(
                    type="CORS Misconfiguration",
                    level=VulnerabilityLevel.HIGH,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="CORS가 자격 증명과 함께 모든 출처를 허용합니다",
                    evidence=f"Access-Control-Allow-Origin: * 및 Allow-Credentials: true로 설정되어 있습니다",
                    recommendation="허용된 출처를 명시적으로 지정하고, 자격 증명 사용 시 와일드카드를 피하세요",
                    cwe_id="CWE-942"
                ))

            # Reflects arbitrary origin
            elif acao == 'https://evil.com':
                vulns.append(Vulnerability(
                    type="CORS Misconfiguration",
                    level=VulnerabilityLevel.MEDIUM,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description="CORS가 임의의 출처를 반영합니다",
                    evidence=f"Access-Control-Allow-Origin이 요청자의 출처를 반영합니다",
                    recommendation="허용된 출처의 화이트리스트를 구현하세요",
                    cwe_id="CWE-942"
                ))

        except requests.exceptions.RequestException:
            pass

        return vulns

    def _check_sensitive_data(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for sensitive data exposure."""
        vulns = []

        # Check URL for sensitive patterns
        sensitive_patterns = [
            (r'password', 'Password in URL'),
            (r'api[_-]?key', 'API Key in URL'),
            (r'secret', 'Secret in URL'),
            (r'token', 'Token in URL'),
            (r'ssn|social[_-]security', 'SSN in URL'),
            (r'credit[_-]?card', 'Credit Card in URL'),
        ]

        url_lower = endpoint.url.lower()
        
        # Korean translations for sensitive patterns
        pattern_desc_kr = {
            'Password in URL': 'URL에 패스워드 포함',
            'API Key in URL': 'URL에 API 키 포함',
            'Secret in URL': 'URL에 비밀 정보 포함',
            'Token in URL': 'URL에 토큰 포함',
            'SSN in URL': 'URL에 주민등록번호 포함',
            'Credit Card in URL': 'URL에 신용카드 정보 포함'
        }
        
        for pattern, desc in sensitive_patterns:
            if re.search(pattern, url_lower):
                vulns.append(Vulnerability(
                    type="Sensitive Data Exposure",
                    level=VulnerabilityLevel.MEDIUM,
                    endpoint=endpoint.url,
                    method=endpoint.method,
                    description=f"{pattern_desc_kr.get(desc, desc)} 파라미터가 감지되었습니다",
                    evidence=f"URL에 민감한 패턴이 포함되어 있습니다: {pattern}",
                    recommendation="민감한 데이터를 요청 본문이나 헤더로 이동하고, 암호화를 사용하세요",
                    cwe_id="CWE-200"
                ))

        # Check response for sensitive data
        if endpoint.response_example:
            response_lower = endpoint.response_example.lower()
            for pattern, desc in sensitive_patterns:
                if re.search(pattern, response_lower):
                    vulns.append(Vulnerability(
                        type="Sensitive Data Exposure",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description=f"API 응답에 {pattern_desc_kr.get(desc, desc)} 정보가 포함되어 있습니다",
                        evidence=f"응답에 민감한 패턴이 포함되어 있습니다: {pattern}",
                        recommendation="응답에서 민감한 데이터를 마스킹하거나 제거하세요",
                        cwe_id="CWE-200"
                    ))

        return vulns

    def _check_rate_limiting(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Check for rate limiting."""
        vulns = []

        try:
            # Send multiple rapid requests
            responses = []
            for i in range(5):
                response = self.session.request(
                    endpoint.method,
                    endpoint.url,
                    timeout=self.timeout,
                    verify=False
                )
                responses.append(response.status_code)

            # If all succeed, no rate limiting
            if all(code == 200 for code in responses):
                # Check for rate limit headers
                has_rate_limit_headers = any(
                    h in response.headers
                    for h in ['X-RateLimit-Limit', 'X-Rate-Limit', 'RateLimit-Limit']
                )

                if not has_rate_limit_headers:
                    vulns.append(Vulnerability(
                        type="Missing Rate Limiting",
                        level=VulnerabilityLevel.MEDIUM,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description="Rate Limiting이 감지되지 않았습니다",
                        evidence="Rate Limit 헤더 없이 여러 빠른 요청이 모두 성공했습니다",
                        recommendation="남용 및 DoS 공격을 방지하기 위해 Rate Limiting을 구현하세요",
                        cwe_id="CWE-770"
                    ))

        except requests.exceptions.RequestException:
            pass

        return vulns

    def _check_sql_injection(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Enhanced SQL injection check (Error-based + Boolean-based)."""
        vulns = []

        # Only check endpoints with parameters
        if not endpoint.parameters:
            return vulns

        # Extended SQL injection payloads
        error_based_payloads = [
            "'",
            "\"",
            "1' OR '1'='1",
            "1\" OR \"1\"=\"1",
            "'; DROP TABLE users--",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' or 1=1--",
            "' or 1=1#",
            "' or 1=1/*",
            "') or '1'='1--",
            "') or ('1'='1--",
            "1' ORDER BY 1--",
            "1' ORDER BY 100--",
            "1' UNION SELECT NULL--",
            "1' AND 1=CONVERT(int, (SELECT @@version))--",
            "' AND EXTRACTVALUE(1, CONCAT(0x5c, (SELECT version())))--",
        ]

        # Boolean-based blind SQL injection payloads
        boolean_true_payloads = [
            "1' AND '1'='1",
            "1\" AND \"1\"=\"1",
            "1' AND 1=1--",
            "1') AND ('1'='1",
            "1' AND 'a'='a",
            "1' AND SUBSTRING(@@version,1,1)='5",
        ]

        boolean_false_payloads = [
            "1' AND '1'='2",
            "1\" AND \"1\"=\"2",
            "1' AND 1=2--",
            "1') AND ('1'='2",
            "1' AND 'a'='b",
            "1' AND SUBSTRING(@@version,1,1)='0",
        ]

        try:
            for param_name in endpoint.parameters.keys():
                # ===== 1. ERROR-BASED SQL INJECTION CHECK =====
                for payload in error_based_payloads[:5]:  # Test first 5 payloads
                    test_url = endpoint.url
                    if '?' in test_url:
                        test_url += f"&{param_name}={quote(payload)}"
                    else:
                        test_url += f"?{param_name}={quote(payload)}"

                    try:
                        response = self.session.request(
                            endpoint.method,
                            test_url,
                            timeout=self.timeout,
                            verify=False
                        )

                        # Check for SQL error messages (extended list)
                        sql_errors = [
                            'sql syntax', 'mysql', 'postgresql', 'ora-', 'sqlite',
                            'syntax error', 'unclosed quotation', 'quoted string not properly terminated',
                            'you have an error in your sql syntax', 'warning: mysql',
                            'valid mysql result', 'mysqlclient', 'postgresql query failed',
                            'supplied argument is not a valid postgresql', 'unterminated quoted string',
                            'pg_query()', 'pg_exec()', 'sqlite_query', 'sqlite_fetch',
                            'mssql_query()', 'odbc_exec()', 'oracle error', 'ora-01756',
                            'sqlexception', 'db2 sql error', 'jdbc', 'sqlstate',
                        ]

                        response_text = response.text.lower()
                        if any(error in response_text for error in sql_errors):
                            vulns.append(Vulnerability(
                                type="SQL Injection (Error-based)",
                                level=VulnerabilityLevel.CRITICAL,
                                endpoint=endpoint.url,
                                method=endpoint.method,
                                description=f"응답에서 SQL 오류 메시지가 감지되었습니다",
                                evidence=f"'{param_name}' 파라미터에서 페이로드 '{payload}'를 사용하여 SQL 오류가 발생했습니다",
                                recommendation="매개변수화된 쿼리/Prepared Statement를 사용하고, 입력 검증을 수행하며, ORM을 활용하세요. 사용자 입력을 SQL 쿼리에 직접 연결하지 마세요.",
                                cwe_id="CWE-89"
                            ))
                            return vulns  # Found vulnerability, no need to continue

                    except requests.exceptions.RequestException:
                        continue

                # ===== 2. BOOLEAN-BASED BLIND SQL INJECTION CHECK =====
                try:
                    # Get baseline response (normal parameter)
                    baseline_url = endpoint.url
                    if '?' in baseline_url:
                        baseline_url += f"&{param_name}=1"
                    else:
                        baseline_url += f"?{param_name}=1"
                    
                    baseline_response = self.session.request(
                        endpoint.method,
                        baseline_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    baseline_length = len(baseline_response.text)
                    baseline_status = baseline_response.status_code

                    # Test TRUE condition
                    true_url = endpoint.url
                    true_payload = boolean_true_payloads[0]
                    if '?' in true_url:
                        true_url += f"&{param_name}={quote(true_payload)}"
                    else:
                        true_url += f"?{param_name}={quote(true_payload)}"
                    
                    true_response = self.session.request(
                        endpoint.method,
                        true_url,
                        timeout=self.timeout,
                        verify=False
                    )

                    # Test FALSE condition
                    false_url = endpoint.url
                    false_payload = boolean_false_payloads[0]
                    if '?' in false_url:
                        false_url += f"&{param_name}={quote(false_payload)}"
                    else:
                        false_url += f"?{param_name}={quote(false_payload)}"
                    
                    false_response = self.session.request(
                        endpoint.method,
                        false_url,
                        timeout=self.timeout,
                        verify=False
                    )

                    # Boolean-based detection logic
                    true_length = len(true_response.text)
                    false_length = len(false_response.text)
                    
                    # Check if TRUE and FALSE responses differ significantly
                    # TRUE should be similar to baseline, FALSE should be different
                    length_diff_threshold = 100  # bytes
                    
                    baseline_true_diff = abs(baseline_length - true_length)
                    baseline_false_diff = abs(baseline_length - false_length)
                    true_false_diff = abs(true_length - false_length)
                    
                    # Vulnerability conditions:
                    # 1. TRUE response similar to baseline AND different from FALSE
                    # 2. Response lengths differ significantly between TRUE and FALSE
                    if (baseline_true_diff < length_diff_threshold and 
                        true_false_diff > length_diff_threshold):
                        
                        vulns.append(Vulnerability(
                            type="SQL Injection (Boolean-based Blind)",
                            level=VulnerabilityLevel.CRITICAL,
                            endpoint=endpoint.url,
                            method=endpoint.method,
                            description=f"불린 기반 블라인드 SQL 인젝션이 감지되었습니다",
                            evidence=f"'{param_name}' 파라미터에서 TRUE 조건({true_length} bytes)과 FALSE 조건({false_length} bytes)에 대해 서로 다른 응답이 나타났습니다",
                            recommendation="매개변수화된 쿼리/Prepared Statement를 사용하고, 입력 검증을 수행하며, ORM을 활용하세요. 사용자 입력을 SQL 쿼리에 직접 연결하지 마세요.",
                            cwe_id="CWE-89"
                        ))
                        return vulns

                except requests.exceptions.RequestException:
                    continue

        except Exception as e:
            print(f"[!] SQL injection check error: {e}")

        return vulns

    def _check_xss(self, endpoint: APIEndpoint) -> List[Vulnerability]:
        """Basic XSS check."""
        vulns = []

        # Only check endpoints with parameters
        if not endpoint.parameters:
            return vulns

        xss_payload = "<script>alert('XSS')</script>"

        try:
            for param_name in endpoint.parameters.keys():
                test_url = endpoint.url
                if '?' in test_url:
                    test_url += f"&{param_name}={xss_payload}"
                else:
                    test_url += f"?{param_name}={xss_payload}"

                response = self.session.request(
                    endpoint.method,
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )

                # Check if payload is reflected unescaped
                if xss_payload in response.text:
                    vulns.append(Vulnerability(
                        type="Possible XSS",
                        level=VulnerabilityLevel.HIGH,
                        endpoint=endpoint.url,
                        method=endpoint.method,
                        description=f"사용자 입력이 살균 처리 없이 반영되었습니다",
                        evidence=f"'{param_name}' 파라미터가 XSS에 취약할 수 있습니다",
                        recommendation="입력 살균 처리(sanitization) 및 출력 인코딩을 구현하세요",
                        cwe_id="CWE-79"
                    ))
                    break

        except requests.exceptions.RequestException:
            pass

        return vulns

    def get_vulnerabilities(self) -> List[Vulnerability]:
        """Get all discovered vulnerabilities."""
        return self.vulnerabilities

    def get_vulnerabilities_by_level(self, level: VulnerabilityLevel) -> List[Vulnerability]:
        """Get vulnerabilities filtered by severity level."""
        return [v for v in self.vulnerabilities if v.level == level]

    def get_statistics(self) -> Dict:
        """Get vulnerability statistics."""
        return {
            'total': len(self.vulnerabilities),
            'critical': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.CRITICAL)),
            'high': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.HIGH)),
            'medium': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.MEDIUM)),
            'low': len(self.get_vulnerabilities_by_level(VulnerabilityLevel.LOW)),
        }

    def clear(self):
        """Clear vulnerabilities."""
        self.vulnerabilities.clear()

    @staticmethod
    def generate_poc(vuln: Vulnerability) -> Optional[str]:
        """
        ?�️ DEPRECATED: This template-based PoC generation method is deprecated.
        
        All PoC generation now uses AI-powered generation via AIJSAnalyzer.
        This method will be removed in a future version.
        
        Please use AIJSAnalyzer.generate_vulnerability_poc() instead.
        
        Args:
            vuln: 취약??객체

        Returns:
            PoC 코드 문자??(deprecated, raises NotImplementedError)
        """
        raise NotImplementedError(
            "Template-based PoC generation has been removed. "
            "Please use AI-powered PoC generation via AIJSAnalyzer.generate_vulnerability_poc() instead. "
            "Configure OpenAI API key in config.yaml to enable AI PoC generation."
        )
